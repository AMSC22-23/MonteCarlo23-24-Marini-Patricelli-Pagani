#include <cuda.h>
#include <curand_kernel.h>
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>

#define L 64
#define N (L*L)
#define J 1.00
#define IT 5e5
#define NTHREADS 256
#define BLOCK_DIM 16
#define TCRIT 2.26918531421

__device__ int get_index(int row, int col) {
    return (row * L + col) % N;
}

__device__ int delta_energy(bool* __restrict__ lattice, int r, int c, int lr, int lc, int block_dim) {
    int sum = 0;

    // Neighbor indices
    int north = ((lr - 1 + block_dim) % block_dim) * block_dim + lc;
    int south = ((lr + 1) % block_dim) * block_dim + lc;
    int west = lr * block_dim + (lc - 1 + block_dim) % block_dim;
    int east = lr * block_dim + (lc + 1) % block_dim;

    // Read from shared memory
    sum += lattice[north] + lattice[south] + lattice[west] + lattice[east];

    // Convert sum from bool to [-4, 4]
    sum = 2 * sum - 4;

    // Current spin
    int idx = lr * block_dim + lc;
    int spin = lattice[idx] ? 1 : -1;

    return 2 * spin * sum;
}

__global__ void flip_spins(bool* __restrict__ lattice, float* __restrict__ prob, curandState* __restrict__ states, float* __restrict__ energy, int* __restrict__ M, bool update_black) {
    extern __shared__ bool shared_lattice[];

    int global_idx = blockIdx.x * blockDim.x + threadIdx.x;
    int r = global_idx / L;
    int c = global_idx % L;
    int lr = threadIdx.x / BLOCK_DIM;
    int lc = threadIdx.x % BLOCK_DIM;
    int local_idx = lr * BLOCK_DIM + lc;
    bool is_black = ((r + c) % 2 == 0);

    // Load spins into shared memory
    shared_lattice[local_idx] = lattice[global_idx];
    __syncthreads();

    if (is_black == update_black) {
        int delta = delta_energy(shared_lattice, r, c, lr, lc, BLOCK_DIM);
        float rnd = curand_uniform(&states[global_idx]);

        if (delta <= 0 || (delta == 4 && rnd < prob[0]) || (delta == 8 && rnd < prob[1])) {
            // Flip spin
            shared_lattice[local_idx] = !shared_lattice[local_idx];
            lattice[global_idx] = !lattice[global_idx];

            // Important to atomic add to global memory, not shared memory
            atomicAdd(energy, delta * J);
            atomicAdd(M, 2 * (shared_lattice[local_idx] ? 1 : -1));
        }
    }
    __syncthreads();
}

__global__ void setup_kernel(curandState* state, unsigned long seed) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N) {
        curand_init(seed, idx, 0, &state[idx]);
    }
}

__global__ void initialize_lattice_kernel(bool* lattice, curandState* states, float* energy, int* M) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N) {
        lattice[idx] = curand_uniform(&states[idx]) > 0.5f;

        // Calculate magnetization
        atomicAdd(M, lattice[idx] ? 1 : -1);
    }
}

int main() {
    bool* dev_lattice;
    float* dev_energy;
    int* dev_M;
    float* dev_prob;
    curandState* dev_states;

    dim3 blocks(N / NTHREADS);
    dim3 threads(NTHREADS);

    // Allocate memory
    cudaMalloc(&dev_lattice, N * sizeof(bool));
    cudaMalloc(&dev_energy, sizeof(float));
    cudaMalloc(&dev_M, sizeof(int));
    cudaMalloc(&dev_prob, 2 * sizeof(float));
    cudaMalloc(&dev_states, N * sizeof(curandState));

    // Initialize RNG
    setup_kernel << <blocks, threads >> > (dev_states, time(nullptr));

    // Initialize lattice
    initialize_lattice_kernel << <blocks, threads >> > (dev_lattice, dev_states, dev_energy, dev_M);

    // Iterate over temperature
    for (float T = 0.2f; T <= 3.0f; T += 0.1f) {
        float prob[2] = { exp(-4.0f * J / T), exp(-8.0f * J / T) };

        // Copy to device
        cudaMemcpy(dev_prob, prob, 2 * sizeof(float), cudaMemcpyHostToDevice);

        float energy;
        int M;

        // Monte Carlo simulation
        for (int iter = 0; iter < IT; iter += 2) {
            flip_spins << <blocks, threads, NTHREADS * sizeof(bool) >> > (dev_lattice, dev_prob, dev_states, dev_energy, dev_M, true);
            flip_spins << <blocks, threads, NTHREADS * sizeof(bool) >> > (dev_lattice, dev_prob, dev_states, dev_energy, dev_M, false);
        }

        // Copy results to host
        cudaMemcpy(&energy, dev_energy, sizeof(float), cudaMemcpyDeviceToHost);
        cudaMemcpy(&M, dev_M, sizeof(int), cudaMemcpyDeviceToHost);

        // Output results
        std::cout << "Temperature: " << T << "\n";
        std::cout << "Energy: " << energy / N << "\n";
        std::cout << "Magnetization: " << static_cast<float>(M) / N << "\n";
    }

    // Free memory
    cudaFree(dev_lattice);
    cudaFree(dev_energy);
    cudaFree(dev_M);
    cudaFree(dev_prob);
    cudaFree(dev_states);

    return 0;
}
