#include <iostream>
#include <curand.h>
#include <curand_kernel.h>

// Define lattice dimensions and other constants
const int L = 512; // Lattice size (LxL)
const int N = L * L;
const float J = 1.0f;
const float beta = 1.0f; // Inverse temperature

// The kernel for updating a single spin
__global__ void updateSpins(int* lattice, curandState* state, int color, float beta) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if ((x < L) && (y < L)) {
        int site = y * L + x;
        if ((x + y) % 2 == color) { // Check color (checkerboard pattern)
            // Calculate the site index of the 4 neighbors
            int left = site - 1;
            int right = site + 1;
            int up = site - L;
            int down = site + L;

            // Handle periodic boundary conditions
            if (x == 0) left += L;
            if (x == L - 1) right -= L;
            if (y == 0) up += N;
            if (y == L - 1) down -= N;

            // Calculate energy difference if this spin is flipped
            int dE = 2 * lattice[site] * (lattice[left] + lattice[right] + lattice[up] + lattice[down]);
            float r = curand_uniform(&state[site]);

            // Metropolis criterion
            if (dE <= 0 || r < expf(-beta * dE)) {
                lattice[site] *= -1;
            }
        }
    }
}

// Initialize CURAND states for each thread
__global__ void setupRandStates(curandState* state, unsigned long seed) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    int site = y * L + x;
    if (x < L && y < L) {
        curand_init(seed, site, 0, &state[site]);
    }
}
// The kernel for calculating the total energy of the lattice
__global__ void computeEnergy(int* lattice, int* energy) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if ((x < L) && (y < L)) {
        int site = y * L + x;

        // Calculate the site index of the 4 neighbors
        int right = (x == L - 1) ? site - (L - 1) : site + 1;
        int down = (y == L - 1) ? site - (L - 1) * L : site + L;

        // Compute the contribution of the current spin to the energy (each bond counted once)
        int e = -lattice[site] * (lattice[right] + lattice[down]);

        // Use atomicAdd to safely accumulate the total energy
        atomicAdd(energy, e);
    }
}

int main() {
    int* d_lattice;
    curandState* d_states;
    int* d_energy;
    cudaMalloc(&d_energy, sizeof(int));


    // Allocate memory on the device for lattice and states
    cudaMalloc(&d_lattice, N * sizeof(int));
    cudaMalloc(&d_states, N * sizeof(curandState));

    // Set up kernel launch parameters
    dim3 blocks(L / 16, L / 16);
    dim3 threads(16, 16);

    // Initialize spins on the lattice
    int* h_lattice = new int[N];
    for (int i = 0; i < N; i++) {
        h_lattice[i] = 1; // All spins set to 1
    }
    cudaMemcpy(d_lattice, h_lattice, N * sizeof(int), cudaMemcpyHostToDevice);

    // Set up the RNG states
    setupRandStates << <blocks, threads >> > (d_states, time(NULL));

    // Create CUDA event objects for timing
    cudaEvent_t start, stop;
    cudaEventCreate(&start);
    cudaEventCreate(&stop);

    for (float T = 0.2f; T <= 3.0f; T += 0.1f) {
        float beta = 1.0f / T;

        // Initialize energy to 0 for each temperature step
        int initial_energy = 0;
        cudaMemcpy(d_energy, &initial_energy, sizeof(int), cudaMemcpyHostToDevice);

        // Record the start event
        cudaEventRecord(start);

        for (int iter = 0; iter < 1e4; iter++) {
            updateSpins << <blocks, threads >> > (d_lattice, d_states, iter % 2, beta);
        }

        // After spin updates are done, compute the energy of the system
        computeEnergy << <blocks, threads >> > (d_lattice, d_energy);

        // Record the stop event and wait for it to complete
        cudaEventRecord(stop);
        cudaEventSynchronize(stop);

        // Copy the lattice and energy back to the host to compute magnetization and retrieve energy
        cudaMemcpy(h_lattice, d_lattice, N * sizeof(int), cudaMemcpyDeviceToHost);
        int host_energy;
        cudaMemcpy(&host_energy, d_energy, sizeof(int), cudaMemcpyDeviceToHost);

        // Calculate magnetization
        int magnetization = 0;
        for (int i = 0; i < N; i++) {
            magnetization += h_lattice[i];
        }
        float magnetization_per_site = static_cast<float>(magnetization) / N;

        // Calculate the energy per site
        float energy_per_site = static_cast<float>(host_energy) / N;

        // Calculate elapsed time
        float milliseconds = 0;
        cudaEventElapsedTime(&milliseconds, start, stop);

        // Print temperature, magnetization per site, energy per site, and elapsed time
        std::cout << "Temperature: " << T
            << ", Magnetization per site: " << magnetization_per_site
            << ", Energy per site: " << energy_per_site
            << ", Time: " << milliseconds << " ms" << std::endl;
    }

    // Clean up resources
    cudaEventDestroy(start);
    cudaEventDestroy(stop);
    cudaFree(d_lattice);
    cudaFree(d_states);
    delete[] h_lattice;

    return 0;
}
