#include <cmath>
#include <cstdlib>
#include <vector>
#include <iostream>
#include<fstream>
#include<tuple>
#include<ctime>
#include <omp.h>
#include <chrono>
#include <random>

// The output is wrong,even though it compiles and run. The time for each iteration 100*100 is around 90 seconds.
// It must be tested. I have no idea of the functioning of some of the things I implemented here, a bit too much of copy paste.




#define L 100
#define N (L*L)
#define J 1.00
#define IT 5e8 //number of iterations
#define NTHREADS 12

void print_lattice(std::vector < std::vector<int> >& matrix) {

    int i, j;
    for (i = 0; i < L; i++) {
        std::cout << std::endl;
        for (j = 0; j < L; j++) {
            if (matrix[i][j] == -1) {
                std::cout << "o" << " ";
            }
            else {
                std::cout << "x" << " ";

            }
        }
    }
}

//if needed function to correctly evaluate energy
float evaluate(std::vector < std::vector<int> >& matrix) {
    int sum = 0;
    for (int i = 0; i < L; i++) {
        for (int j = 0; j < L; j++) {

            if (i != 0) {
                sum += matrix[i - 1][j] * matrix[i][j] * 2;
            }
            if (j != 0) {
                sum += matrix[i][j - 1] * matrix[i][j] * 2;
            }

            if (i == L - 1) {
                sum += matrix[0][j] * matrix[i][j] * 2; //times 2 two count also contribute where i = 0
            }
            if (j == L - 1) {
                sum += matrix[i][0] * matrix[i][j] * 2;
            }
        }
    }
    return -J * sum;
}

void flip(std::vector<std::vector<int>>& matrix, std::vector<float>& prob, float& energy, int& M, int r, int c) {
    static thread_local std::mt19937 rng(std::random_device{}()); // Each thread gets a RNG
    std::uniform_real_distribution<float> dist(0.0, 1.0);

    int sum = 0;


    if (r == 0) {
        sum += matrix[L - 1][c];
    }
    else {
        sum += matrix[r - 1][c];
    }
    if (c == 0) {
        sum += matrix[r][L - 1];
    }
    else {
        sum += matrix[r][c - 1];
    }

    if (r == L - 1) {
        sum += matrix[0][c];
    }
    else {
        sum += matrix[r + 1][c];
    }
    if (c == L - 1) {
        sum += matrix[r][0];
    }
    else {
        sum += matrix[r][c + 1];
    }
    int delta = 2 * sum * matrix[r][c];
    if (delta <= 0) {
        matrix[r][c] = -matrix[r][c];
    }
    else if (delta == 4) {
        float rnd = (rand() % 10000) / 1e4;
        if (rnd < prob[0]) {
            matrix[r][c] = -matrix[r][c];
        }
        else {
            return;
        }
    }
        if (delta <= 0) {
            matrix[r][c] = -matrix[r][c];
        }
        else {
            float rnd = dist(rng); // Use thread-local RNG
            if (delta == 4 && rnd < prob[0]) {
                matrix[r][c] = -matrix[r][c];
            }
            else if (delta == 8 && rnd < prob[1]) {
                matrix[r][c] = -matrix[r][c];
            }
            else {
                return;
            }
        }

#pragma omp atomic
    energy += 2 * delta * J;
#pragma omp atomic
    M += 2 * matrix[r][c];
}

void initialize_lattice(std::vector < std::vector<int> >& matrix, float& energy, int& M) {
    int k;
    int size = L;
    int sum = 0;
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            k = rand() % 2;
            if (k == 0) {
                matrix[i][j] = -1;
                M -= 1;
            }
            else {
                matrix[i][j] = 1;
                M += 1;
            }
            //energy contibute
            if (i != 0) {
                sum += matrix[i - 1][j] * matrix[i][j] * 2;
            }
            if (j != 0) {
                sum += matrix[i][j - 1] * matrix[i][j] * 2;
            }

            if (i == L - 1) {
                sum += matrix[0][j] * matrix[i][j] * 2; //times 2 two count also contribute where i = 0
            }
            if (j == L - 1) {
                sum += matrix[i][0] * matrix[i][j] * 2;
            }
        }
    }
    energy += -J * sum;
}






int write_file(std::vector<float>& energy_vec, std::vector<float>& m, std::vector<int>& t) {
    std::ofstream myfile("data.txt");
    if (myfile.is_open())
    {
        for (int i = 0; i < t.size(); i++) {
            myfile << energy_vec[i] << " " << abs(m[i]) << ' ' << t[i] << '\n';
        }
        myfile.close();
    }
    else std::cout << "Unable to open file";
    return 0;
}



float simulate(float T, std::vector < std::vector<int> >& lattice, float& energy, int& M, std::vector<std::tuple<int, int>>& rand_vect) {

    using namespace std;
    vector<float> prob(2);
    prob[0] = exp(-4 * J / T);
    prob[1] = exp(-8 * J / T);

    vector<float> energy_vec(1);
    energy_vec[0] = energy;

    vector<float> m(1);
    m[0] = (float)M / N;
    vector<int> t_axis(1);
    t_axis[0] = 0;
    int i;
    for (i = 1; i < IT; i++) {
        flip(lattice, prob, energy, M, std::get<0>(rand_vect[i]), std::get<1>(rand_vect[i]));
        if (i % N == 0) {
            // aggiornare l'energia e la magnetizzazione ogni N step (definizione di tempo nel metropolis come da libro)
            m.push_back((float)M / N); // magnetizzazione media per sito
            energy_vec.push_back(energy);
            t_axis.push_back(i / N);

        }
    }
    return m.back();
}

void create_rand_vect_parallel(std::vector<std::tuple<int, int>>& rand_vect_0, unsigned int seed) {
    rand_vect_0.resize(IT); // Preallocate space to avoid thread-safety issues with push_back
#pragma omp parallel num_threads(NTHREADS)
    {
        std::mt19937 rng(seed ^ omp_get_thread_num()); // Separate RNG for each thread
#pragma omp for
        for (int i = 1; i < IT; i++) {
            rand_vect_0[i] = std::make_tuple(rng() % L, rng() % L); // Direct assignment using preallocated vector space
        }
    }
}

void create_rand_vect_parallel(std::vector<std::tuple<int, int>>& rand_vect_0) {
    int i;
#   pragma omp parallel for  NTHREADS 
    for (i = 1; i < IT; i++) {
        rand_vect_0.push_back(std::make_tuple(rand() % L, rand() % L));
    }
}

float simulate_parallel(float T, std::vector<std::vector<int>>& lattice, float& energy, int& M, std::vector<std::tuple<int, int>>& rand_vect) {
    using namespace std;
    vector<float> prob(2);
    prob[0] = exp(-4 * J / T);
    prob[1] = exp(-8 * J / T);

    size_t num_time_steps = IT / N;
    vector<float> energy_vec(num_time_steps, 0.0); // Preallocated to zero
    vector<float> m(num_time_steps, 0.0); // Preallocated to zero

    // Declare thread-local copies of energy and M
    vector<float> energy_local(NTHREADS, energy);
    vector<int> M_local(NTHREADS, M);

#pragma omp parallel num_threads(NTHREADS)
    {
        int thread_id = omp_get_thread_num();
#pragma omp for
        for (int i = 1; i < IT; i++) {
            // Get thread-local energy and M for the current thread
            float& e_local = energy_local[thread_id];
            int& m_local = M_local[thread_id];

            flip(lattice, prob, e_local, m_local, get<0>(rand_vect[i]), get<1>(rand_vect[i]));

            // Update the energy and magnetisation vectors independently
            if (i % N == 0) {
                int index = i / N;
                energy_vec[index] = e_local;
                m[index] = static_cast<float>(m_local) / N;
            }
        }
    }

    // Combine the thread-local energies and magnetizations
    for (int t_id = 0; t_id < NTHREADS; ++t_id) {
        energy += energy_local[t_id] - energy; // Subtract the initial energy, added to each thread-local copy
        M += M_local[t_id] - M; // Subtract the initial M, added to each thread-local copy
    }

    // Compute the average final energy and magnetization
    float final_energy = energy_vec.back();
    float final_magnetization = static_cast<float>(M) / N;

    return final_magnetization;
}




int main() {
    unsigned seed = time(0);
    srand(seed);
    using namespace std;
    vector<vector<int> > lattice(L, vector<int>(L));
    float energy = 0;
    int M = 0;
    initialize_lattice(lattice, energy, M);
    float T = 0.1;
    vector<float> results(1);
    results[0] = 1;
    std::vector<std::tuple<int, int>> rand_vect(1);
    rand_vect[0] = make_tuple(rand() % L, rand() % L);
    create_rand_vect_parallel(rand_vect);


    while (T <= 3.5) {
        auto start = std::chrono::high_resolution_clock::now();  // Start timing before simulation

        results.push_back(simulate_parallel(T, lattice, energy, M, rand_vect));

        auto end = std::chrono::high_resolution_clock::now();  // End timing after simulation
        std::chrono::duration<double> elapsed = end - start;  // Calculate elapsed time

        T += 0.1;

        cout << "Time taken for simulation at temperature " << T << ": " << elapsed.count() << " seconds" << endl;
        cout << abs(results.back()) << endl;
    }



    return 0;

}
